import numpy as np
from mdp import *
from tmis import TMIS2
from algs import *
H = 5	
S = 2
A = 2

N = 10000

env = ToyEnv(5, np.array([1/2, 1/2]))


# Gather UCB-adaptive data #

print("running sarsa -----")
F = sarsa(env, N, .2, .3)

D_sarsa = F[0]
Pi_sarsa = F[1]

# print("D_sarsa = ", D_sarsa)
###########################

# Gather shadow data #
print("gathering shadow data using sarsa pols ----")
# print("length Î  = ", len(Pi_sarsa))
# print("Pi = ", Pi_sarsa)
env.reset()
D_shadow = env.rollout_multipol(Pi_sarsa, .2)
print(D_shadow)
# print()
###########################
import matplotlib.pyplot as plt

pi = Pi_sarsa[-1]
print("pi = ", pi)


vpi = env.M.evaluate(pi)

adaptive_estimates = []
shadow_estimates = []

# y_ad = list(np.load("adaptive.npy"))
# y_sh = list(np.load("shadow.npy"))
y_ad = []
y_sh = []
print("forming estimates")

tmis_sarsa = TMIS2(D_sarsa, H, S, A, env.r)
tmis_shadow = TMIS2(D_shadow, H, S, A, env.r)


M = N
for n in range(0, M):
	if n % 100 == 0:
		print("n = ", n)
		# print("vhat_ucb = ", vhat_ucb)

	vhat_sarsa = tmis_sarsa.evaluate(pi, n)
	vhat_sh = tmis_shadow.evaluate(pi, n)
	# print("vhat_ucb ", vhat_ucb)
# 	adaptive_estimates.append(vhat_ucb)
# 	shadow_estimates.append(vhat_sh)
	y_ad.append(n*(vpi - vhat_sarsa)**2)
	y_sh.append(n*(vpi - vhat_sh)**2)

# print("min nhsa sarsa = ", np.amin(tmis_sarsa.nhsa[n]))
print("P shadow = ",tmis_shadow.calc_Phat(N))
# print(len(y_ad))
print("True P = ", env.P)
# print(y_ad)
# np.save("adaptive", np.array(y_ad))
# np.save("shadow", np.array(y_sh))
# plt.rcParams["text.usetex"] = True
plot_step = 1
plt.plot(np.arange(1, M)[::plot_step], y_ad[::plot_step], label = "adaptive")
plt.plot(np.arange(1, M)[::plot_step], y_sh[::plot_step], label = "shadow dataset")
plt.title("Performance of TMIS estimator with Adaptivity Generated by SARSA")
plt.ylabel("$n \\times(\hat{v}^\pi - v^\pi)^2$")
plt.xlabel("n")
plt.legend()

plt.show()








